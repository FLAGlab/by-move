load "list-of.ath"
load "config.ath"
module Actor{
    open Cfg
    open List

    ##################################################################### Sort definitions 
    domains Expression, Value, Flag
    declare NORMAL, KILL, EXIT: Value
    declare ff, tt: Flag
    
    # TODO: FrameStack incomplete definition, just define the needed for Figure.3.Pag.13 
    datatype FrameStack := (bang' Ide) | (exit' Ide) | link' | unlink'
    datatype Signal := (msg Value) | (exit Value Flag) | link | unlink 
    datatype Action := (send Ide Ide Signal) | (rec Value) | (self Ide) | 
                       (arr Ide Ide Signal) | (spawn Ide Expression Expression) | 
                       sequential | termination | Flag
    datatype Actor := (LiveActor Ide FrameStack Expression (List Value) (List Ide) Flag)
                     |(TerminatedActor (List Ide))  


    # THIS IS QUIET IMPORTANT! Notice how I achieve to define the datatype Actor || Action
    # To do so I had to introduce two constructors: Actor/1 and Action/1. I mean it kinda
    # makes sense but at the same time it does not.
    datatype ConfigElement := (Actor Actor) | (Action Action)

    ################################################################ Variables definitions 
    define [frameStack expression mailbox linkedActors flag 
            flag0 actorIde actorIdeTo actorIdeFrom value config config0]
            :=
            [
                ?frameStack:      FrameStack
                ?expression:      Expression
                ?mailbox:         (List Value)
                ?linkedActors:    (List Ide)
                ?flag:            Flag
                ?flag0:            Flag
                ?actorIde:        Ide
                ?actorIdeTo:      Ide
                ?actorIdeFrom:    Ide
                ?value:           Value
                ?config:          (Cfg ConfigElement) 
                ?config0:         (Cfg ConfigElement) 
            ] 

    # TODO: Give a documentation for reduce
    # This function reduce defines the 'arrow' in the paper
    declare reduce : [(Cfg ConfigElement)] -> (Cfg ConfigElement) 
    # declare ArrReduction : [Actor Action] -> Actor
    ############################################################## Process local semantics
    ############################################################## Just Some abbreviations
    define msg'           := (msg value)
    define exit'          := (exit value flag0)
    define arr-msg'       := (Action (arr actorIdeFrom actorIdeTo msg'))
    define arr-exit'      := (Action (arr actorIdeFrom actorIdeTo exit')) 
    define arr-link'      := (Action (arr actorIdeFrom actorIdeTo link)) 
    define actor'         := (Actor (LiveActor actorIdeTo frameStack expression mailbox linkedActors flag))
    define arr-msg-actor' := (Actor (LiveActor actorIdeTo frameStack expression (mailbox ++ [value]) linkedActors flag))
    ###################################################################################### 
    assert* reduce-arr := 
                        (
                            (reduce 
                                (cg config (cg (One actor') (One arr-msg')))
                            )
                            = 
                            (cg config (One arr-msg-actor'))
                        )
    # assert* arr-exit-drop-0 := 
    #                         (
    #                             (not (actorIdeFrom = actorIdeTo)) &
    #                             (flag = ff) &
    #                             (value = NORMAL) & 
    #                             (
    #                                 (ArrReduction actor' arr-exit')
    #                                 =
    #                                 actor'
    #                             )
    #                         )

    # assert* arr-exit-drop-1 :=
    #                         (
    #                             (not (actorIdeFrom = actorIdeTo)) &
    #                             (not (actorIdeFrom in linkedActors)) &
    #                             (flag = ff) &
    #                             (
    #                                 (ArrReduction actor' arr-exit')
    #                                 =
    #                                 actor'
    #                             )
    #                         )
    # # TODO: ExitTerm and ExitConv rule page 12

    # assert* arr-link := ( 
    #                         (ArrReduction actor' arr-link')
    #                         =
    #                         (
    #                             LiveActor 
    #                                 actorIdeTo
    #                                 frameStack
    #                                 expression
    #                                 mailbox
    #                                 ( actorIdeFrom :: linkedActors )
    #                                 flag
    #                         ) 
    #                     )
    
    # TODO: UnlinkArr, to achieve this I need to implement the rem operation

    ############################################################## Process-local semantics

}