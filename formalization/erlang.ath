load "list-of.ath"
load "config.ath"
module Actor{
    open Cfg
    open List

    ##################################################################### Sort definitions 
    domains Expression, Flag

    declare ff, tt: Flag
    declare NORMAL, KILL, EXIT, TRUE, OK : Expression 
    
    # TODO: FrameStack incomplete definition, just define the needed for Figure.3.Pag.13 
    datatype FrameStack :=  
            (bang' Expression) 
        | (exit' Expression) 
        | (frame' Expression)
        | link' 
        | unlink'
    # TODO: The definition of signals is over values (Pag.4) here the definition is over
    #       expressions, that is because the second field of an actor is an expression
    #       but when defining Send (Pag.13) they are assuming that there is a value in 
    #       such expression.
    # TEMPORALLY THERE IS NOT GOING TO EXIT THE VALUE SORT EXPRESSION IS GOING TO 
    # ENCAPSULATE ALL SUCH BEHAVIOR PROBABLY AT THIS MOMENT I DO NOT NEED SUCH GRANULARITY. 
    datatype Signal :=   
          (msg Expression)
        | (exit Expression Flag)
        | link
        | unlink 
    datatype Action :=  
          (send Expression Expression Signal)
        | (rec Expression)
        | (self Expression)
        | (arr Expression Expression Signal)
        | (spawn Expression Expression Expression)
        | sequential
        | termination
        | Flag
    # TODO: To define link (Pag.13) I need to have Ide < Expression. As right now, I don't
    #       how to achieve that. The temporally solution is to define, fixed process IDEs
    #       and use them as expressions. 
    # Stack, Expression, Mailbox, LinkedActors, Flag
    datatype Actor := 
          (LiveActor Expression (List FrameStack) Expression (List Expression) (List Expression) Flag)
        | (TerminatedActor (List Expression))  


    # THIS IS QUIET IMPORTANT! Notice how I achieve to define the datatype Actor || Action
    # To do so I had to introduce two constructors: Actor/1 and Action/1. I mean it kinda
    # makes sense but at the same time it does not.
    datatype ConfigElement := 
          (Actor Actor)
        | (Action Action)

    ################################################################ Variables definitions 
    define [frameStackList expression expression0 mailbox linkedActors flag config 
            actorIde actorIdeTo actorIdeFrom actorIdeLink]
            :=
            [
                ?frameStackList:(List FrameStack) 
                ?expression:    Expression
                ?expression0:   Expression
                ?mailbox:       (List Expression)
                ?linkedActors:  (List Expression)
                ?flag:          Flag
                ?config:        (Cfg ConfigElement) 
                ?actorIde:      Expression
                ?actorIdeTo:    Expression
                ?actorIdeFrom:  Expression
                ?actorIdeLink:  Expression
            ] 

    # This function defines the arrow in the paper, it would be call reduce for future, references.
    declare --> : [(Cfg ConfigElement) (Cfg ConfigElement)] ->  Boolean
    # TODO: I make the decision of delete all the other rules that I have already write,
    #       In this point just need the definition for send and arrive. This also help me
    #       reduce the points of failures for this very first 'proof of concept', it is
    #       clear that I have to fully define all the rules! (Future work)

    ############################################################## Process local semantics
    ###
    ############################################################## Just Some abbreviations
    define msg_exp      := (msg expression0)
    define bang         := (bang' actorIdeTo)
    define arr_msg      := (Action (arr actorIdeFrom actorIdeTo msg_exp))
    define send_msg     := (Action (send actorIdeFrom actorIdeTo msg_exp))
    define to_actor     := (Actor (LiveActor actorIdeTo frameStackList expression mailbox linkedActors flag))
    define actor        := (Actor (LiveActor actorIdeFrom frameStackList expression mailbox linkedActors flag))
    define send_actor   := (Actor (LiveActor actorIdeFrom (bang :: frameStackList) expression0 mailbox linkedActors flag))
    define arr_msg_actor:= (Actor (LiveActor actorIdeFrom frameStackList expression (mailbox ++ [expression0]) linkedActors flag))
    ###################################################################################### 
    # TODO: Define all the assert for reduce inside just one fun as in RAFT
    assert* reduce_arr_msg := 
        (
            (cg config (cg (One to_actor) (One arr_msg)))
            -->
            (cg config (One arr_msg_actor))
        )
    
    assert* reduce_send := 
        (
            (cg config (One send_actor))
            -->
            (cg
                config
                (cg
                    (One actor)
                    (One send_msg)
                )
            )
        )

      ############################################################## Transitive reduction 



}