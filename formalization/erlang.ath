load "list-of.ath"
load "config.ath"
module Actor{
    open Cfg
    open List

    ##################################################################### Sort definitions 
    domains Expression, Flag
    declare NORMAL, KILL, EXIT, TRUE, OK, IDE, IDETO, IDEFROM : Expression 
    declare ff, tt: Flag
    
    # TODO: FrameStack incomplete definition, just define the needed for Figure.3.Pag.13 
    datatype FrameStack := (bang' Expression) | (exit' Expression) | link' | unlink'
    # TODO: The definition of signals is over values (Pag.4) here the definition is over
    #       expressions, that is because the second field of an actor is an expression
    #       but when defining Send (Pag.13) they are assuming that there is a value in 
    #       such expression.
    # TEMPORALLY THERE IS NOT GOING TO EXIT THE VALUE SORT EXPRESSION IS GOING TO 
    # ENCAPSULATE ALL SUCH BEHAVIOR PROBABLY AT THIS MOMENT I DO NOT NEED SUCH GRANULARITY. 
    datatype Signal := (msg Expression) | (exit Expression Flag) | link | unlink 
    datatype Action := (send Expression Expression Signal) | (rec Expression) | (self Expression) | 
                       (arr Expression Expression Signal) | (spawn Expression Expression Expression) | 
                       sequential | termination | Flag
    # TODO: To define link (Pag.13) I need to have Ide < Expression. As right now, I don't
    #       how to achieve that. The temporally solution is to define, fixed process IDEs
    #       and use them as expressions. 
    datatype Actor := (LiveActor Expression (List FrameStack) Expression (List Expression) (List Expression) Flag)
                     |(TerminatedActor (List Expression))  


    # THIS IS QUIET IMPORTANT! Notice how I achieve to define the datatype Actor || Action
    # To do so I had to introduce two constructors: Actor/1 and Action/1. I mean it kinda
    # makes sense but at the same time it does not.
    datatype ConfigElement := (Actor Actor) | (Action Action)

    ################################################################ Variables definitions 
    define [frameStackList expression mailbox linkedActors flag 
            flag0 expression0 config config0]
            :=
            [
                ?frameStackList:  (List FrameStack) 
                ?expression:      Expression
                ?mailbox:         (List Expression)
                ?linkedActors:    (List Expression)
                ?flag:            Flag
                ?flag0:           Flag
                ?expression0:     Expression
                ?config:          (Cfg ConfigElement) 
                ?config0:         (Cfg ConfigElement) 
            ] 

    # TODO: Give a documentation for reduce
    # This function reduce defines the 'arrow' in the paper
    declare reduce : [(Cfg ConfigElement)] -> (Cfg ConfigElement) 
    # declare ArrReduction : [Actor Action] -> Actor
    ############################################################## Process local semantics
    ############################################################## Just Some abbreviations
    define exit^          := (exit' IDE)
    define msg^           := (msg expression0)
    define bang^          := (bang' IDETO)
    define ff-exit^       := (exit expression ff)
    define flag-exit^     := (exit expression0 flag0)
    define arr-msg^       := (Action (arr IDEFROM IDETO msg^))
    define arr-link^      := (Action (arr IDEFROM IDETO link)) 
    define arr-exit^      := (Action (arr IDEFROM IDETO flag-exit^)) 
    define send-msg^      := (Action (send IDEFROM IDETO msg^))
    define send-msg-exit^ := (Action (send IDEFROM IDETO ff-exit^))
    define true-actor^    := (Actor (LiveActor IDEFROM frameStackList TRUE mailbox linkedActors flag))
    define to-actor^      := (Actor (LiveActor IDETO frameStackList expression mailbox linkedActors flag))
    define actor^         := (Actor (LiveActor IDEFROM frameStackList expression mailbox linkedActors flag))
    define send-actor^    := (Actor (LiveActor IDEFROM (bang^ :: frameStackList) expression mailbox linkedActors flag))
    define exit-actor^    := (Actor (LiveActor IDEFROM (exit^ :: frameStackList) expression mailbox linkedActors flag))
    define link-actor^    := (Actor (LiveActor IDEFROM (link' :: frameStackList) expression mailbox linkedActors flag))
    define arr-link-actor^:= (Actor (LiveActor IDETO frameStackList expression mailbox ( IDEFROM :: linkedActors ) flag))
    define arr-msg-actor^ := (Actor (LiveActor IDEFROM frameStackList expression (mailbox ++ [expression0]) linkedActors flag))
    define reduce-drop-exit^ :=
                            (
                                (reduce 
                                    (cg config (cg (One to-actor^) (One arr-exit^)))
                                )
                                =
                                (cg config (One to-actor^))
                            )
    ###################################################################################### 
    # TODO: Define all the assert for reduce inside just one fun as in RAFT
    #       reduce-null is not presented in the paper, just for completeness.
    assert* reduce-null := (reduce Null = Null)
    assert* reduce-arr-msg := 
                        (
                            (reduce 
                                (cg config (cg (One actor^) (One arr-msg^)))
                            )
                            = 
                            (cg config (One arr-msg-actor^))
                        )
    # The paper presents arr-exit-drop-0 and 1 as just one reduction rule, but I think
    # that it is better to have it a two separate rules, thinking on proofs that might
    # need them.
    assert* reduce-arr-exit-drop-0 := 
                            (
                                ((not (IDEFROM = IDETO)) &
                                (flag = ff) &
                                (expression0 = NORMAL)) 
                                ==>
                                reduce-drop-exit^
                            )
    assert* reduce-arr-exit-drop-1 :=
                            (
                                (
                                (not (IDEFROM = IDETO)) &
                                (not (IDEFROM in linkedActors)) &
                                (flag = ff) 
                                ) 
                                ==>
                                reduce-drop-exit^
                            )
    # TODO: ExitTerm and ExitConv rule page 12

    assert* reduce-arr-link := 
                        ( 
                            (reduce 
                                (cg config (cg (One to-actor^) (One arr-link^)))
                            )
                            # (ArrReduction actor^ arr-link^)
                            =
                            (One arr-link-actor^) 
                        )
    
    # TODO: UnlinkArr, to achieve this I need to implement the rem operation

    ############################################################## Process-local semantics

    assert* reduce-send := (
                            (reduce
                                (cg config (One send-actor^))
                            )
                            =
                            (cg
                                config
                                (cg
                                    (One actor^)
                                    (One send-msg^)
                                )
                            )
                          )

    assert* reduce-exit := (
                            (reduce
                                (cg config (One exit-actor^))
                            )
                            =
                            (cg
                                config
                                (cg
                                    (One true-actor^)
                                    (One send-msg-exit^)
                                )
                            )
                           )

    assert* reduce-exit := (
                            (reduce
                                (cg config (One exit-actor^))
                            )
                            =
                            (cg
                                config
                                (cg
                                    (One true-actor^)
                                    (One send-msg-exit^)
                                )
                            )
                           )
                        
    
    # TODO: check if I can documentate using github issued
}